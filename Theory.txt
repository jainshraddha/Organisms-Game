Theory 


1. let array A be the given array, such that A.length() = n 
Create another array called frequencyA of length n-1 
Since we know that the values are only between 1 and n-1, we can increment the index of the frequencyA array, as soon as we hit a value in the original array. 
The way to find if there’s an element that occurs more than 1, is to keep a if statement check on the frequencyA array: if (frequencyA[i] > 1), we have found our duplicate value. 
	This operation takes O(n) time in the worst case since we are only traversing the array once. 



2. 

a. The order of growth: 
The outer loop runs n times 
The inner loop runs 5 times for each time the outer loop runs 
Thus, the algorithm runs O(5n) times, where we can drop the 5, as its a constant. (This is assuming that the addition happens in constant time) 


b. The order of growth: 
	1. The 3rd loop will execute when j is a multiple of i (i times) 
	2. The 2nd for loop will run O(i^2 + ((i^2(i+1)/2)) - because the j loop is essentially saying:
		 prime = i*j and for(int k from 0 to prime, k++)
	3. Thus, this is O(i^3) for the 2nd loop. 
	4. Finally, the outermost (1st) loop runs n times. 
	5. So the total run time is O(n^4)




3. f(x) = 3x^4 + 5x^3 + 17x^2 + 13x + 5; g(x) = x^4
f(x) >= c(g(x)) ———— 1 

c*(3x^4 + 5x^3 + 17x^2 + 13x + 5) >= x^4

∃ c > 0, ∀ n > n_o (where n_o is the base value for which the equality holds) 

(∃ n_o > 0)

let c = 4, x = 1; 

4*(3(1) + 5(1) + 17(1) + 13(1) + 5) >= (1)  ———(from 1)  

= 4*43 >= 1

= 172 >= 1

So, the equality holds. 
